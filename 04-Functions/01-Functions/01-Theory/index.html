<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions - JavaScript</title>

	<link rel="stylesheet" href="https://md-block.verou.me/prism.css">
    <link rel="stylesheet" href="https://md-block.verou.me/style.css">
    <link rel="stylesheet" href="../../00-assets/custom.css">

    <script type="module" src="https://md-block.verou.me/md-block.js"></script>
    <!-- <link href="https://live.prismjs.com/prism-live.css" rel="stylesheet"> -->
</head>
<body>
    <main>
        <md-block hlinks>

## Defining a Function

In JavaScript, a function is a block of reusable code that performs a specific task. It allows you to group related code together and execute it whenever needed. To define a function, you can use the `function` keyword followed by the function name, parentheses for parameters (optional), and curly braces for the function body. Here's an example:

```javascript
function greet(name) {
    console.log("Hello, " + name + "!");
}
```

In the above code, we defined a function called `greet` that takes a parameter `name`. The function body simply logs a greeting message to the console.

---

## Binding and Scopes

Binding and scopes are crucial concepts in JavaScript that help determine the accessibility and visibility of variables and functions within a program. They play a significant role in how variables and functions are accessed and interact with each other.

1. Binding:
   - Binding refers to the association of a name (identifier) with a value in JavaScript. It involves declaring and assigning a value to a variable or function.
   - Variables: When you declare a variable using keywords like `var`, `let`, or `const`, you create a binding between the variable name and its value. This allows you to store and retrieve values using the variable name.
   - Functions: When you declare a function, you create a binding between the function name and the entire function body. This allows you to call and execute the function using its name.

2. Scopes:
   - Scopes define the visibility and accessibility of variables and functions within a program. They determine where variables and functions are accessible and where they are not.
   - Global Scope: Variables and functions declared outside of any function are considered to be in the global scope. They are accessible from anywhere within the program, including inside functions.
   - Local Scope: Variables and functions declared within a function are considered to be in the local scope. They are accessible only within the function in which they are declared. Local scopes are sometimes referred to as function scopes.
   - Block Scope (Introduced in ES6): Variables declared with `let` and `const` keywords have block scope, meaning they are accessible only within the block of code (inside curly braces) where they are declared. Block scope includes `if` statements, `for` loops, and other blocks of code.

Here's an example to illustrate binding and scopes:

```javascript
// Global Scope
var globalVar = 'I am a global variable';

function example() {
  // Local Scope
  var localVar = 'I am a local variable';
  console.log(globalVar); // Output: I am a global variable
  console.log(localVar); // Output: I am a local variable
}

example();

console.log(globalVar); // Output: I am a global variable
console.log(localVar); // Error: localVar is not defined

// Block Scope
function blockExample() {
  if (true) {
    let blockVar = 'I am a block-scoped variable';
    console.log(blockVar); // Output: I am a block-scoped variable
  }
  console.log(blockVar); // Error: blockVar is not defined
}

blockExample();
```

In the above code, we have a global variable `globalVar` that is accessible from both within and outside the `example` function. It has global scope.

The `example` function has a local variable `localVar` that is accessible only within the function. It has local scope.

In the `blockExample` function, we have a block-scoped variable `blockVar` declared using the `let` keyword. It is accessible only within the block of code where it is declared.

Understanding binding and scopes is essential for managing variable and function accessibility and avoiding naming conflicts. It allows you to organize and structure your code in a way that prevents unintended interactions between different parts of your program.

---

## Functions as Values

The concept of functions as values refers to the ability to treat functions in JavaScript as regular data types, just like strings, numbers, or objects. In JavaScript, functions can be assigned to variables, passed as arguments to other functions, returned from functions, and stored in data structures like arrays or objects. This flexibility allows for powerful and dynamic programming techniques.

Here are some key points to understand about functions as values:

1. Assigning Functions to Variables:
   - In JavaScript, you can assign a function to a variable just like you would assign a value to a variable.
   - This allows you to store functions in variables and use them later by invoking the variable as if it were a function.
   - This is particularly useful when you want to pass functions as arguments or return them from other functions.

```javascript
// Assigning function to a variable
const sayHello = function() {
  console.log('Hello!');
};

sayHello(); // Output: Hello!
```

2. Passing Functions as Arguments:
   - JavaScript allows you to pass functions as arguments to other functions.
   - This is known as "higher-order functions" and is a powerful technique for creating more flexible and reusable code.
   - The receiving function can then call the passed function within its own body.

```javascript
// Passing function as an argument
function repeat(func, numTimes) {
  for (let i = 0; i < numTimes; i++) {
    func();
  }
}

function sayHi() {
  console.log('Hi!');
}

repeat(sayHi, 3);
// Output:
// Hi!
// Hi!
// Hi!
```

3. Returning Functions from Functions:
   - In JavaScript, functions can also return other functions.
   - This allows you to create functions that generate and customize other functions based on certain conditions or parameters.

```javascript
// Returning a function from a function
function createMultiplier(multiplier) {
  return function(num) {
    return num * multiplier;
  };
}

const double = createMultiplier(2);
console.log(double(5)); // Output: 10
```

In the above code, the `createMultiplier` function takes a `multiplier` parameter and returns an anonymous function. The returned function takes a `num` parameter and multiplies it by the `multiplier` value.

By calling `createMultiplier(2)`, we create a new function `double` that multiplies its argument by 2. When we call `double(5)`, it returns the result of `5 * 2`, which is 10.

Functions as values provide a lot of flexibility and enable powerful programming techniques such as higher-order functions, function composition, and functional programming paradigms. They allow you to write more modular, reusable, and expressive code.

---

## Declaration Notation

The concept of declaration notation refers to the different ways you can declare and define variables and functions in JavaScript. There are two common ways to declare variables and functions: using the `var` keyword and using the `function` keyword.

Let's break down the declaration notation for both variables and functions:

1. Variable Declaration Notation:
   - `var` keyword: In older versions of JavaScript, the `var` keyword was used to declare variables. Variables declared with `var` are function-scoped, meaning they are accessible within the function in which they are declared. If `var` is used outside of any function, the variable becomes globally scoped.
   - `let` and `const` keywords: With the introduction of ECMAScript 6 (ES6), the `let` and `const` keywords were introduced as alternatives to `var`. Variables declared with `let` and `const` are block-scoped. Block scope means that variables are only accessible within the block of code (inside curly braces) where they are declared. `let` allows for reassigning the variable's value, while `const` creates a variable that cannot be reassigned.

Here's an example to illustrate variable declaration notation:

```javascript
// Using var (function-scoped)
function example() {
  var x = 5;
  if (true) {
    var y = 10;
    console.log(x); // Output: 5
  }
  console.log(y); // Output: 10
}
example();

// Using let (block-scoped)
function example2() {
  let x = 5;
  if (true) {
    let y = 10;
    console.log(x); // Output: 5
  }
  console.log(y); // Error: y is not defined
}
example2();

// Using const (block-scoped, non-reassignable)
const PI = 3.14;
console.log(PI); // Output: 3.14
PI = 3.14159; // Error: Assignment to constant variable
```

2. Function Declaration Notation:
   - `function` keyword: Functions in JavaScript can be declared using the `function` keyword. Function declarations are hoisted, which means they are moved to the top of their scope during the compilation phase. This allows you to call a function before it is defined in the code.
   - Function expressions: In addition to function declarations, you can also define functions using function expressions. Function expressions involve assigning a function to a variable or passing it as an argument to another function. Function expressions are not hoisted and must be defined before they are called.

Here's an example to illustrate function declaration notation:

```javascript
// Function declaration
function greet() {
  console.log('Hello!');
}
greet(); // Output: Hello!

// Function expression
var sayHello = function() {
  console.log('Hello!');
};
sayHello(); // Output: Hello!
```

In the above code, we have a function declaration for `greet` that can be called anywhere in the code, even before the actual declaration.

We also have a function expression where a function is assigned to the `sayHello` variable. Function expressions are defined at the point where they are assigned. They are not hoisted and must be defined before they are called.

Declaration notation allows you to define variables and functions in JavaScript using different keywords and syntaxes. Understanding the differences between `var`, `let`, `const`, function declarations, and function expressions is essential for writing clean and maintainable code.

---

## Arrow Functions

Arrow functions, also known as fat arrow functions, are a concise syntax introduced in ECMAScript 6 (ES6) that allows you to create functions in a more compact and expressive way. Arrow functions are especially useful for writing shorter and more readable code.

Here are some key features and characteristics of arrow functions:

1. Syntax: The syntax of an arrow function is `(parameters) => { code }`, where `parameters` can be zero or more parameters, and `code` represents the body of the function. If the function has a single parameter, the parentheses around the parameter can be omitted.

2. Implicit Return: Arrow functions have an implicit return feature, which means that if the function body consists of a single expression, that expression will be automatically returned without the need for an explicit `return` statement.

3. Lexical `this` Binding: Unlike regular functions, arrow functions do not have their own `this` value. Instead, they inherit the `this` value from the surrounding context (also known as lexical scoping). This can be particularly useful when dealing with callbacks or working with object methods.

4. No `arguments` Object: Arrow functions do not have their own `arguments` object. If you need to access the arguments passed to an arrow function, you can use the rest parameter syntax (`...args`) to capture them.

Let's see some examples to better understand arrow functions:

```javascript
// Example 1: Arrow function without parameters
const sayHello = () => {
  console.log('Hello!');
};

sayHello(); // Output: Hello!

// Example 2: Arrow function with a single parameter
const double = (num) => {
  return num * 2;
};

console.log(double(5)); // Output: 10

// Example 3: Arrow function with implicit return
const multiply = (a, b) => a * b;

console.log(multiply(2, 3)); // Output: 6

// Example 4: Arrow function with lexical `this` binding
const person = {
  name: 'John',
  greet: function() {
    setTimeout(() => {
      console.log(`Hello, my name is ${this.name}`);
    }, 1000);
  }
};

person.greet(); // Output: Hello, my name is John
```

In Example 1, we define an arrow function `sayHello` without any parameters. When called, it simply logs 'Hello!' to the console.

In Example 2, we define an arrow function `double` with a single parameter `num`. It multiplies the parameter by 2 and returns the result.

In Example 3, we define an arrow function `multiply` with two parameters `a` and `b`. Since the function body consists of a single expression (`a * b`), it can be written in a shorter form without the curly braces and the `return` keyword.

In Example 4, we demonstrate the lexical `this` binding of arrow functions. Inside the `greet` method of the `person` object, we use a setTimeout function to delay the execution of the arrow function. The arrow function has access to the `this` value of the surrounding context, which is the `person` object in this case.

Arrow functions are a powerful and convenient addition to JavaScript, allowing you to write more concise and readable code. However, it's important to note that they have some differences compared to regular functions, such as the absence of their own `this` value and the `arguments` object.

---

## The Call Stack

The call stack is a mechanism used by JavaScript to keep track of function calls. It is a data structure that stores information about the active functions and their execution contexts. When a function is called, it gets pushed onto the call stack, and when it returns, it gets popped off the stack.

```javascript
function first() {
    second();
    console.log("First function");
}

function second() {
    console.log("Second function");
}

first();
```

In the above code, when the `first` function is called, it pushes itself onto the call stack. Inside the `first` function, the `second` function is called, which also gets pushed onto the call stack. The `second` function logs a message to the console and returns, so it gets popped off the stack. Finally, the `first` function logs a message to the console and returns, completing the execution.

#### Some More Explanation...

The call stack is a fundamental concept in JavaScript that helps manage the execution of functions. It keeps track of the order in which functions are called and executed, allowing the program to remember where to return to after a function call is completed.

When a JavaScript program starts running, it begins with the execution of the global scope, which includes any global variables and function declarations. As functions are called within the program, they are added to the call stack.

Here's how the call stack works:

1. Function Calls: Whenever a function is called, a new frame is created and pushed onto the call stack. This frame contains information about the function call, including the function's parameters and local variables.

2. Execution: The function at the top of the call stack is the one currently being executed. The program executes the code within that function until it either encounters a return statement or reaches the end of the function.

3. Return: When a function completes its execution, the frame representing that function is popped off the call stack. This allows the program to return to the previous point of execution, which is the function that called the completed function.

4. Stack Order: Functions are added to the call stack in a last-in, first-out (LIFO) order. This means that the most recently added function is the one that gets executed first and completed last.

The call stack plays a crucial role in maintaining the flow of execution in JavaScript programs. It ensures that functions are called and returned in the correct order, allowing the program to keep track of its execution state.

Here's an example to illustrate the call stack:

```javascript
function multiply(a, b) {
  return a * b;
}

function square(n) {
  var result = multiply(n, n);
  return result;
}

function printResult() {
  var result = square(5);
  console.log(result);
}

printResult(); // Output: 25
```

In the above code, we have three functions: `multiply`, `square`, and `printResult`. The `printResult` function calls the `square` function, which in turn calls the `multiply` function.

When `printResult()` is called, it is added to the call stack. The `square` function is then called, and it is added to the call stack on top of `printResult`. Within the `square` function, the `multiply` function is called and added to the call stack.

Once the `multiply` function completes its execution, it is popped off the call stack. The control returns to the `square` function, which then completes its execution and is also popped off the call stack. Finally, the control returns to the `printResult` function, which completes its execution and is popped off the call stack as well.

The call stack allows the program to maintain the correct order of execution and keeps track of where to return after a function completes its execution.

Understanding the call stack is essential for debugging and understanding the flow of execution in JavaScript programs. It helps identify the order of function calls and can be useful in pinpointing errors or infinite loops.

---

## Optional Arguments

In JavaScript, function parameters can be optional. You can define default values for parameters in case they are not provided when the function is called. This allows you to make certain arguments optional and provide a fallback value if they are not specified.

```javascript
function greet(name = "stranger") {
    console.log("Hello, " + name + "!");
}

greet(); // Output: Hello, stranger!
greet("Alice"); // Output: Hello, Alice!
```

In the above code, the `greet` function has an optional parameter `name` with a default value of "stranger". If no argument is provided, it uses the default value. If an argument is provided, it uses the provided value.

---

## Closure

The concept of closure in JavaScript is a powerful and often misunderstood concept. A closure is created when a function is defined within another function and has access to its parent function's variables, even after the parent function has finished executing.

To understand closures, let's break down the concept into its components:

1. Lexical Scope: In JavaScript, every function creates its own scope, and variables declared within a function are accessible within that function's scope and any nested scopes. This concept is known as lexical scope.

2. Nested Functions: JavaScript allows you to define functions inside other functions. When a function is defined within another function, it forms a closure. The inner function has access to the variables and parameters of the outer function, as well as any variables in its own scope.

3. Returning Functions: Closures become particularly useful when an inner function is returned from the outer function. Since the inner function maintains a reference to the variables of its parent function, even after the parent function has finished executing, the inner function can still access and manipulate those variables.

Here's an example to demonstrate closures:

```javascript
function outer() {
  var outerVariable = 'Hello';

  function inner() {
    console.log(outerVariable);
  }

  return inner;
}

var closureFunction = outer();
closureFunction(); // Output: Hello
```

In the above code, the `outer` function defines a variable `outerVariable` and a nested function `inner`. The `inner` function, being a closure, has access to the `outerVariable` even after the `outer` function has finished executing.

When we call `outer()`, it returns the `inner` function. We store this returned function in the `closureFunction` variable. Later, when we invoke `closureFunction()`, it prints the value of `outerVariable`, which is 'Hello'. This is possible because the `inner` function maintains a reference to its parent function's variables, creating a closure.

Closures are commonly used in JavaScript to create private variables and encapsulated behavior. By defining variables within an outer function and exposing only the necessary functions that operate on those variables, we can achieve data hiding and encapsulation.

Here's an example that demonstrates using closures to create private variables:

```javascript
function Counter() {
  var count = 0;

  function increment() {
    count++;
    console.log(count);
  }

  function decrement() {
    count--;
    console.log(count);
  }

  return {
    increment: increment,
    decrement: decrement
  };
}

var counter = Counter();
counter.increment(); // Output: 1
counter.increment(); // Output: 2
counter.decrement(); // Output: 1
```

In this example, the `Counter` function returns an object with two methods: `increment` and `decrement`. These methods can access and modify the private `count` variable, which remains hidden from the outside world. Each time we call `counter.increment()` or `counter.decrement()`, the count is incremented or decremented, respectively.

Closures are a powerful and versatile concept in JavaScript. They allow us to create functions that can access and manipulate variables from their parent functions, even after those parent functions have finished executing. By understanding closures, you can leverage their capabilities to write more flexible and expressive code.

---

## Recursion

Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems. It is a powerful tool that allows you to solve complex problems by reducing them to simpler cases.

When a function calls itself, it is called a recursive function, and each recursive call creates a new instance of the function with its own set of variables and execution context. The function continues to call itself until it reaches a base case, which is a condition that stops the recursion and returns a specific value.

Here's a step-by-step explanation of how recursion works:

1. Identify the base case: The base case is a condition that determines when the recursion should stop and return a specific value. It acts as the termination condition for the recursive calls.

2. Define the recursive case: The recursive case is the part of the function where it calls itself with a modified set of parameters. This allows the function to break down the problem into smaller subproblems.

3. Call the function recursively: Inside the recursive case, the function calls itself with a modified set of parameters. This creates a new instance of the function and repeats the process with the smaller subproblem.

4. Return and combine results: As the recursive calls unwind, each instance of the function returns its result. These results are then combined or processed to get the final result.

To illustrate the concept of recursion, let's consider an example of calculating the factorial of a number:

```javascript
function factorial(n) {
  // Base case: if n is 0 or 1, return 1
  if (n === 0 || n === 1) {
    return 1;
  } else {
    // Recursive case: multiply n with factorial of (n - 1)
    return n * factorial(n - 1);
  }
}

console.log(factorial(5)); // Output: 120
```

In the above code, the `factorial` function takes a number `n` as input and calculates its factorial. It uses recursion to break down the problem into smaller subproblems by calling itself with `(n - 1)`.

Here's how the recursion unfolds for `factorial(5)`:

1. `factorial(5)` calls `factorial(4)` and waits for the result.
2. `factorial(4)` calls `factorial(3)` and waits for the result.
3. `factorial(3)` calls `factorial(2)` and waits for the result.
4. `factorial(2)` calls `factorial(1)` and waits for the result.
5. `factorial(1)` returns 1 (base case).
6. `factorial(2)` multiplies 2 with the result of `factorial(1)` and returns 2.
7. `factorial(3)` multiplies 3 with the result of `factorial(2)` and returns 6.
8. `factorial(4)` multiplies 4 with the result of `factorial(3)` and returns 24.
9. `factorial(5)` multiplies 5 with the result of `factorial(4)` and returns 120 (final result).

Recursion can be a powerful technique, but it's important to use it wisely and ensure that the base case is reached. Otherwise, it can lead to infinite recursion, causing the program to run indefinitely.

---

## Growing Functions

The concept of "Growing Functions" refers to the process of gradually adding more functionality to existing functions as the codebase evolves and new requirements arise. It involves expanding the scope and capabilities of a function without fundamentally changing its purpose or breaking existing functionality.

When you start developing a program or application, it is often recommended to create small, focused functions that perform specific tasks. These functions are easier to understand, test, and maintain. However, as your codebase grows and becomes more complex, you may find the need to add more functionality to these functions.

The idea behind growing functions is to build upon the existing foundation of small functions rather than creating entirely new functions from scratch. This approach helps maintain code organization, reduces code duplication, and improves code readability. It also allows you to leverage the existing logic and structures in your codebase.

Here's an example to illustrate the concept of growing functions:

```javascript
function calculateArea(length, width) {
  return length * width;
}

function calculatePerimeter(length, width) {
  return 2 * (length + width);
}

function calculateVolume(length, width, height) {
  return length * width * height;
}
```

In the above code, we have three separate functions: `calculateArea`, `calculatePerimeter`, and `calculateVolume`. Each function calculates a different geometric property based on the given dimensions.

Now, let's say we want to add a new function `calculateDiagonal` to calculate the diagonal length of a rectangle. Instead of creating a completely new function, we can leverage the existing functions and build upon them:

```javascript
function calculateDiagonal(length, width) {
  const area = calculateArea(length, width);
  return Math.sqrt(2 * area);
}
```

In the `calculateDiagonal` function, we call the `calculateArea` function to get the area of the rectangle. We then use this area value to calculate the diagonal length using the Pythagorean theorem.

By growing the `calculateDiagonal` function in this way, we avoid duplicating code and maintain consistency with the existing functions. If there are any changes or improvements needed in the `calculateArea` function, it will automatically reflect in the `calculateDiagonal` function as well.

The key principle of growing functions is to keep functions modular, reusable, and focused on specific tasks. As your codebase evolves, you can continue to expand the existing functions to accommodate new requirements without sacrificing code organization or readability.

        </md-block>
    </main>
</body>
</html>